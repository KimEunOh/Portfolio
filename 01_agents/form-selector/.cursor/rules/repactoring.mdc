---
description: 
globs: 
alwaysApply: false
---
# Form Selector 프로젝트 Cursor Rules

## 📚 필수 워크플로 (모든 작업 시작 전 확인)

### 🔄 문서 기반 개발 사이클
```
1. 문서 참조 → 2. 코딩 → 3. 문서 업데이트 → 4. 커밋
```

### ✅ 작업 시작 전 체크리스트
- [ ] `documents/PROGRESS_TRACKING.md`에서 현재 Phase 및 해야 할 작업 확인
- [ ] `documents/DIRECTORY_STRUCTURE.md`에서 관련 파일 위치 및 구조 파악
- [ ] 해당 작업이 리팩토링 방향성과 일치하는지 확인
- [ ] 기존 모듈 구조 활용 방안 검토

### ✅ 작업 완료 후 체크리스트
- [ ] `PROGRESS_TRACKING.md` 업데이트: 완료 체크박스, 성과 지표, 마일스톤
- [ ] `DIRECTORY_STRUCTURE.md` 업데이트: 새 파일 추가, 상태 변경, 메트릭
- [ ] 테스트 실행 및 통과 확인
- [ ] 문서 일관성 검증

---

## 🎯 프로젝트 현황 및 목표

### 프로젝트 개요
다양한 업무 양식(연차신청서, 구매품의서, 개인경비 등)을 AI로 분류하고 정보를 추출하는 Form Selector 시스템입니다.

### 현재 문제점
- `service.py`: 2,090줄의 거대한 파일로 모든 양식 처리 로직이 집중됨
- `index.html`: JavaScript에서 각 양식별 중복 코드 다수 존재
- 단일 책임 원칙 위배, 유지보수성 저하

### 리팩토링 목표 구조
```
form_selector/
├── processors/           # 양식별 처리기
├── converters/          # 데이터 변환기 
├── validators/          # 검증기
└── service.py          # 메인 서비스 (축소)
```

### 우선순위 순서
1. **Phase 1**: ✅ service.py 모듈 분리 (processors/, converters/, validators/) - **완료**
2. **Phase 2**: 🚧 추가 양식 프로세서 구현 - **진행중**
3. **Phase 3**: ⏳ JavaScript 리팩토링 (BaseFormProcessor, 설정 외부화)

---

## 🏗️ 핵심 개발 원칙

### 1. 모듈화 우선 원칙
- **기능별 분리**: 작은 클래스/함수로 모듈화
- **상속 구조**: BaseFormProcessor, BaseConverter 등 기본 클래스 활용
- **단일 책임**: 하나의 클래스/함수는 하나의 책임만
- **DRY 원칙**: 중복 코드 제거, 공통 로직은 기본 클래스에

### 2. 점진적 전환 원칙
- 기존 API 호환성 유지 필수
- 환경 변수 기반 점진적 전환 (`USE_V2_PROCESSING`)
- 단계별 전환으로 서비스 중단 방지
- 회귀 테스트로 안정성 확보

### 3. 테스트 우선 개발
- 새로운 processor 작성 시 테스트 먼저 작성
- 기존 코드 리팩토링 시 회귀 테스트 확인
- 각 모듈별 단위 테스트 필수
- 통합 테스트로 전체 시스템 검증

### 4. 네이밍 컨벤션
- **Processor**: `{form_name}_processor.py`
- **Converter**: `{purpose}_converter.py`
- **Validator**: `{form_name}_validator.py`
- **JavaScript**: `{form-name}-processor.js`

---

## 🛠️ 개발 패턴 및 가이드라인

### 양식 처리 기본 플로우
```
1. 양식 분류 (form classification)
2. 슬롯 추출 (slot extraction) 
3. 데이터 변환 (data conversion)
4. API 페이로드 생성 (payload generation)
```

### 클래스 설계 패턴
```python
# ✅ 좋은 예: 양식별 전용 프로세서
class AnnualLeaveProcessor(BaseFormProcessor):
    def convert_items(self, slots):
        # 연차 신청서 특화 로직
        return self.field_converter.convert_leave_type(slots.get('leave_type'))

# ❌ 나쁜 예: 거대한 단일 함수
def fill_slots_in_template(form_type, slots):
    if form_type == "연차 신청서":
        # 500+ 줄의 로직...
```

### 새로운 양식 추가 프로세스
1. `processors/` 디렉토리에 전용 processor 생성
2. `prompts/` 디렉토리에 프롬프트 파일 추가
3. `templates/` 디렉토리에 HTML 템플릿 추가
4. `static/js/` 디렉토리에 JavaScript 설정 추가
5. 테스트 케이스 작성
6. ProcessorFactory에 등록
7. 문서 업데이트

### JavaScript 리팩토링 규칙
- 공통 로직은 `BaseFormProcessor` 클래스 활용
- 양식별 설정은 `form-configs.js`로 외부화
- 각 양식 processor는 20-30줄로 제한
- `index.html`의 중복 코드 제거

---

## 🚫 금지 사항 & ✅ 권장 사항

### 🚫 절대 금지
#### 일반 개발
- `service.py`에 새로운 양식 처리 로직 추가
- 거대한 함수(100줄 이상) 작성
- JavaScript에서 양식별 중복 코드 작성
- 하드코딩된 설정값 사용

#### AI/LLM 특화
- LLM 응답을 검증 없이 직접 사용자에게 노출
- 프롬프트에 민감정보 하드코딩
- 동기적 LLM 호출로 인한 UI 블로킹
- 토큰 사용량 모니터링 없이 LLM 호출

#### 문서 관리
- 문서 업데이트 없이 작업 완료
- 하나의 문서만 업데이트 (PROGRESS_TRACKING + DIRECTORY_STRUCTURE 세트 관리)
- 마지막 업데이트 날짜 변경 누락
- 임시 파일의 문서 반영

### ✅ 적극 권장
#### 코드 품질
- 공통 유틸리티 함수는 `utils.py` 활용
- 타입 힌트 적극 활용으로 인터페이스 명확화
- 로깅을 통한 디버깅 정보 제공
- 체계적인 에러 핸들링 구현

#### AI/LLM 최적화
- 프롬프트 A/B 테스트로 성능 지속 개선
- LLM 응답 품질 메트릭 수집 및 모니터링
- 양식별 분류 정확도 트래킹
- 슬롯 추출 성공률 모니터링

#### 성능 & 안정성
- 비동기 처리로 응답성 향상
- 캐싱 전략으로 성능 최적화
- 토큰 사용량 최적화
- Graceful Degradation 패턴 적용

---

## 🤖 AI/LLM 특화 가이드라인

### 프롬프트 엔지니어링
```python
# ✅ 좋은 예: 템플릿화된 프롬프트
class BasePromptTemplate:
    def format_prompt(self, form_type: str, context: str) -> str:
        return self.template.format(
            role=self.role,
            form_type=form_type,
            context=context,
            examples=self.get_examples()
        )

# ❌ 나쁜 예: 하드코딩된 프롬프트
def extract_slots(form_content):
    prompt = "분석해줘: " + form_content
```

### LLM 응답 처리 패턴
```python
# ✅ 구조화된 응답 처리
@retry(max_attempts=3)
def extract_slots_safely(self, content: str) -> SlotExtractionResult:
    try:
        raw_response = self.llm.generate(prompt)
        return SlotExtractionResult.parse_raw(raw_response)
    except ValidationError as e:
        logger.warning(f"LLM response validation failed: {e}")
        return self.fallback_extraction(content)

# ✅ 구체적 예외 처리
try:
    classification_result = self.classifier.classify(form_content)
except LLMTimeoutError:
    logger.error("LLM classification timed out")
    return self.fallback_classification(form_content)
except LLMParsingError as e:
    logger.error(f"Failed to parse LLM response: {e}")
    return {"error": "양식 분석 중 오류가 발생했습니다. 다시 시도해주세요."}
```

### AI 핵심 원칙
- **프롬프트 템플릿화**: `prompts/` 디렉토리 활용, 하드코딩 금지
- **Few-shot Learning**: 일관된 예시 패턴으로 응답 품질 향상
- **구조화된 응답**: JSON 스키마 강제로 파싱 오류 최소화
- **재시도 + 폴백**: LLM 실패 시 최대 3회 재시도 후 규칙 기반 처리
- **성능 최적화**: 토큰 사용량 최적화, 배치 처리, 캐싱 전략
- **보안 강화**: PII 보호, XSS 방지, 입출력 검증
- **환경별 관리**: dev/prod 모델 설정, 프롬프트 버전 관리

---

## 📊 문서 관리 체계

### 문서별 관리 책임
| 문서 | 업데이트 시점 | 주요 내용 |
|------|---------------|-----------|
| `PROGRESS_TRACKING.md` | 매 작업 완료 후 | 진행률, 체크리스트, 마일스톤 |
| `DIRECTORY_STRUCTURE.md` | 파일 구조 변경 시 | 디렉토리 구조, 파일 상태, 메트릭 |
| `repactoring.mdc` | 가이드라인 변경 시 | 개발 규칙, 패턴, 워크플로 |

### Git 워크플로 통합
```bash
# 작업 시작 시
cat documents/PROGRESS_TRACKING.md | grep -A 5 "해야 할 작업"
cat documents/DIRECTORY_STRUCTURE.md | grep -A 10 "processors"

# 작업 완료 시
git add documents/
git commit -m "docs: update progress for [processor-name]"
git add .
git commit -m "feat: implement [processor-name] with documentation update"
```

### 자동화된 업데이트 템플릿
```markdown
# PROGRESS_TRACKING.md 업데이트 예시
- [x] **[작업명]**: [양식명] 프로세서
  - [x] [세부 작업 1]
  - [x] [세부 작업 2]

### 📈 성과 지표 업데이트
| 항목 | 이전 값 | 현재 값 | 변화 |
|------|---------|---------|------|
| 구현된 프로세서 수 | 2개 | 3개 | +1개 |

# DIRECTORY_STRUCTURE.md 업데이트 예시
├── 📁 processors/
│   ├── base_processor.py               # ✅ 완료
│   ├── [new_processor].py              # ✅ 새로 추가
│   └── processor_factory.py            # 🔄 확장됨
```

---

## 🎯 문서 기반 개발의 목표

1. **투명한 진행 상황**: 언제든 현재 상태를 정확히 파악 가능
2. **일관된 개발 방향**: 모든 팀원이 동일한 정보로 작업
3. **효율적인 협업**: 문서를 통한 명확한 소통
4. **지속 가능한 개발**: 문서화된 프로세스로 안정적 진행
5. **품질 보장**: 체계적인 검토 과정을 통한 높은 코드 품질

---

**모든 작업은 문서 참조 → 코딩 → 문서 업데이트 → 커밋의 사이클로 진행됩니다!** 